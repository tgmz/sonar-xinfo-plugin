/*******************************************************************************
  * Copyright (c) 14.12.2016 Thomas Zierer.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v2.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v20.html
  *
  * Contributors:
  *    Thomas Zierer - initial API and implementation and/or initial documentation
  *******************************************************************************/
package de.tgmz.maven.plugin.xinfo;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.text.MessageFormat;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.StringEscapeUtils;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.util.PDFTextStripper;

@Mojo(name = "generate", defaultPhase = LifecyclePhase.GENERATE_SOURCES)
public class XinfoMojo extends AbstractMojo {
	private static final String IBM_COPYRIGHT = "© Copyright IBM Corp.";
	private String ruleTemplate;
	private Set<String> rules = new HashSet<>();
			
	@Parameter(defaultValue = "${project.build.directory}", property = "outputDir", required = true)
	private File outputDirectory;
	@Parameter(defaultValue = "de.tgmz.xinfo.rules", property = "targetPackage", required = true)
	private String targetPackage;
	@Parameter(defaultValue = "../ibm/Assembler/asmp1021.pdf", property = "document", required = true)
	private File document;
	@Parameter(defaultValue = "asm", property = "lang", required = true)
	private String lang;
	private int num;

	@Override
	public void execute() throws MojoExecutionException {
		try {
			ruleTemplate = IOUtils.resourceToString("rule.txt", StandardCharsets.UTF_8, this.getClass().getClassLoader());
			
			//Replace license header with a "generated" message 
			int idx = ruleTemplate.indexOf("package");
			ruleTemplate = "//This file was generated by " + this.getClass().getSimpleName() + ". Do not edit!"
					+ System.lineSeparator()
					+ ruleTemplate.substring(idx);
			
			switch (lang) {
			case "pli":
				generatePli();
				break;
			case "cobol":
				generateCobol();
				break;
			case "asm":
				generateAssembler();
				break;
			case "ccpp":
				generateCcpp();
				break;
			default:
				String s = "The language " + lang + " is not supported";
				getLog().error(s);
				getLog().error("Supported languages are:");
				getLog().error("- PL/I: Use \"pli\"");
				getLog().error("- COBOL: Use \"cobol\"");
				getLog().error("- HL Assembler: Use \"asm\"");
				getLog().error("- C/C++: Use \"ccpp\"");
				throw new MojoExecutionException(s);
			}
			
		} catch (IOException e) {
			getLog().error(e);
		}
		
		getLog().info(num + " rules written for language " + lang);
		
		num = 0;
	}
	
	private void generatePli() throws IOException {
		String s = stripPdf(document
				, 9
				, 185
				, IBM_COPYRIGHT
				, "Enterprise PL/I for z/OS: Enterprise PL/I for z/OS Messages and Codes");
		
		createRulesFromString(s, "^IBM\\d{4}I\\s[IWESU]\\s", 3);
		createRulesFromString(s, "^IBM\\d{4}\\s", 1);
	}
	private void generateAssembler() throws IOException {
		String s = stripPdf(document
				, 322
				, 48
				, IBM_COPYRIGHT
				, "High Level Assembler for z/OS & z/VM & z/VSE: Programmer's Guide"
				, "•");
		
		createRulesFromString(s, "(^ASMA\\d{3}[INWESCU]\\s)|(^ASMACMS\\d{3}E\\s)", 2);
	}
	private void generateCcpp() throws IOException {
		String s = stripPdf(document
				, 15
				, 341
				, IBM_COPYRIGHT
				, "z/OS: z/OS XL C/C++ Messages");
		
		createRulesFromString(s, "(^CCN\\d{4}\\s)|(^CDA\\d{4}\\s)", 1);
		createRulesFromString(s, "EDC\\d{4}\\s\\d{2}\\s", 4);
	}
	
	private void generateCobol() throws IOException {
		try(InputStream is = new FileInputStream(document)) {
			List<String> l = IOUtils.readLines(is, StandardCharsets.UTF_8);
			
			StringBuilder sb = new StringBuilder();
			
			for (String s0 : l) {
				if (!(s0.startsWith("1PP 5655-EC6") || s0.trim().length() == 1)) {	// Page header
					sb.append(s0.substring(1).trim());
					sb.append(' ');
				}
			}
			
			String s = sb.toString();
			
			for (String msg : getSections(s, "IGYXX\\d{4}\\-[IWESU]")) {
				String key = msg.substring(0, 9);
				char sev = msg.charAt(10);
				
				String name;
				String desc;
				
				int idx = msg.indexOf('.');
				
				if (idx > 0) {
					name = msg.substring(16, idx).trim();
					desc = msg.substring(16).trim();
				} else {
					name = msg.substring(16).trim();
					desc = name;
				}
				
				writeRule(key, targetPackage, sev, name, desc);
			}
		}
	}
	/**
	 * Converts a pdf to a string, cutting out some lines.
	 * @param doc IBM documentation
	 * @param fromPage strip all pages before
	 * @param numPages number of pages to convert
	 * @param exclude Strings to exclude from result (headers etc.)
	 * @return the converted document as string
	 * @throws IOException if the documentation cannot be read
	 */
	private String stripPdf(File doc, int fromPage, int numPages, String... exclude) throws IOException {
		PDDocument ibmMessagesAndCodes = PDDocument.load(doc);
		
		for (int i = 0; i < fromPage; ++i) {
			ibmMessagesAndCodes.removePage(0);
		}
		
		while (ibmMessagesAndCodes.removePage(numPages))
			;
		
		PDFTextStripper pdfts = new PDFTextStripper();
		
		String s = pdfts.getText(ibmMessagesAndCodes);
		
		ibmMessagesAndCodes.close();
		
		Iterator<String> iterator = s.lines().iterator();
		
		StringBuilder result = new StringBuilder();
		
		while (iterator.hasNext()) {
			String l = iterator.next();
			
			if (!containsAny(l, exclude)) {
				result.append(l);
				result.append(System.lineSeparator());
			}
		}
		
		return result.toString();
	}
	
	private void createRulesFromString(String s, String split, int goBack) throws IOException {
		Pattern p = Pattern.compile(split, Pattern.MULTILINE);
		
		for (String msg : getSections(s, split)) {
			Matcher m = p.matcher(msg);
			
			m.find();
			
			int keyEnd = m.end();
			
			char sev = msg.charAt(keyEnd - 2); // Message always ends with a blank so we must go back 2 chars
			
			if (StringUtils.containsNone(String.valueOf(sev), "INWESU")) {
				sev = 'I';
			}
			
			String name;
			String description;
			String key;
			
			int explanation = msg.indexOf("Explanation");
			
			if (explanation > -1) {
				name = msg.substring(keyEnd, explanation);
				description = msg.substring(explanation);
			} else {
				name = msg.substring(keyEnd);
				description = name;
			}
			
			key = msg.substring(0, keyEnd - goBack).trim();
			name = name.replace(System.lineSeparator(), " ").trim();
			description = description.replace(System.lineSeparator(), " ").trim();
			
			writeRule(key, targetPackage, sev, name, description);
		}
	}
	private List<String> getSections(String documentation, String msgPattern) {
		List<String> result = new LinkedList<>();
		
		Pattern p = Pattern.compile(msgPattern, Pattern.MULTILINE);
		
		Matcher m = p.matcher(documentation);
		
		m.find();
		int sta = m.start();
		
		while (m.find()) {
			int end = m.start();
			result.add(documentation.substring(sta, end));
			
			sta = end;
		}
		
		result.add(documentation.substring(sta));

		return result;
	}
	private void writeRule(String key, String target, char sev, String name, String description) throws IOException {
		if (rules.contains(key)) {
			getLog().warn("Rule " + key +" already added, skipping");

			return;
		}
		
		rules.add(key);
		
		String priority;
		
		switch (sev) {
		case 'I':
		case 'N':
			priority = "INFO";
			break;
		case 'W':
			priority = "MINOR";
			break;
		case 'E':
			priority = "MAJOR";
			break;
		case 'S':
			priority = "CRITICAL";
			break;
		case 'U':
		default:
			priority = "BLOCKER";
			break;
		}
		
		String escapedName = StringEscapeUtils.escapeJava(name);
		String escapedDesc = StringEscapeUtils.escapeJava(description);
		
		String rule = MessageFormat.format(ruleTemplate, key, escapedName.substring(0, Math.min(escapedName.length(), 200)), escapedDesc, target, priority);
		
		Path dir = Paths.get(outputDirectory.getCanonicalPath(), targetPackage.replace('.', File.separatorChar));
		
		Files.createDirectories(dir);
		
		Path f = Paths.get(dir.toString(), key + ".java");
		
		Files.writeString(f, rule, StandardOpenOption.CREATE, StandardOpenOption.WRITE);
		
		++num;
	}
	
	private static boolean containsAny(String line, String... contain) {
		for (String p : contain) {
			if (line.contains(p)) {
				return true;
			}
		}
		
		return false;
	}
	
	public void setDocument(File document) {
		this.document = document;
	}
	public void setLang(String lang) {
		this.lang = lang;
	}
}

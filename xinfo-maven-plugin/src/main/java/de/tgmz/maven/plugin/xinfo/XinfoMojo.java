/*******************************************************************************
  * Copyright (c) 14.12.2016 Thomas Zierer.
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v2.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v20.html
  *
  * Contributors:
  *    Thomas Zierer - initial API and implementation and/or initial documentation
  *******************************************************************************/
package de.tgmz.maven.plugin.xinfo;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.text.MessageFormat;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.text.StringEscapeUtils;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.util.PDFTextStripper;

@Mojo(name = "generate", defaultPhase = LifecyclePhase.GENERATE_SOURCES)
public class XinfoMojo extends AbstractMojo {
	private static final String IBM_COPYRIGHT = "© Copyright IBM Corp.";
	private static class Sysuexit {
		boolean suppress;
		int severity;
	}
	private String ruleTemplate;
	private Set<String> rules = new HashSet<>();
	private Map<String, Sysuexit> ibmuexit = new TreeMap<>();
			
	@Parameter(defaultValue = "${project.build.directory}", property = "outputDir", required = true)
	private File outputDirectory;
	@Parameter(property = "document", required = true)
	private File document;
	@Parameter(property = "lang", required = true)
	private String lang;
	@Parameter(property = "sysuexit", required = false)
	private File sysuexit;

	private String targetPackage;
	private int num;

	@Override
	public void execute() throws MojoExecutionException {
		try {
			ruleTemplate = IOUtils.resourceToString("rule.txt", StandardCharsets.UTF_8, this.getClass().getClassLoader());
			
			//Replace license header with a "generated" message 
			int idx = ruleTemplate.indexOf("package");
			ruleTemplate = "//This file was generated by " + this.getClass().getSimpleName() + ". Do not edit!"
					+ System.lineSeparator()
					+ ruleTemplate.substring(idx);
			
			switch (lang) {
			case "pli":
				targetPackage = "de.tgmz.sonar.plugins.xinfo.rules.generated.pli";
				generatePli();
				break;
			case "cobol":
				targetPackage = "de.tgmz.sonar.plugins.xinfo.rules.generated.cbl";
				generateCobol();
				break;
			case "asm":
				targetPackage = "de.tgmz.sonar.plugins.xinfo.rules.generated.asm";
				generateAssembler();
				break;
			case "ccpp":
				targetPackage = "de.tgmz.sonar.plugins.xinfo.rules.generated.ccpp";
				generateCcpp();
				break;
			default:
				String s = "The language " + lang + " is not supported";
				getLog().error(s);
				getLog().error("Supported languages are:");
				getLog().error("- PL/I: Use \"pli\"");
				getLog().error("- COBOL: Use \"cobol\"");
				getLog().error("- HL Assembler: Use \"asm\"");
				getLog().error("- C/C++: Use \"ccpp\"");
				throw new MojoExecutionException(s);
			}
			
		} catch (IOException e) {
			getLog().error(e);
		}
		
		getLog().info(num + " rules written for language " + lang);
		
		num = 0;
	}
	
	private void generatePli() throws IOException {
		if (sysuexit != null && sysuexit.exists() && sysuexit.isFile()) {
			initExit();
		} else {
			getLog().info("SYSUEXIT file not provided or not found. Default severities apply");
			
			ibmuexit = new TreeMap<>();
		}
		
		String s = stripPdf(document
				, 9
				, 185
				, IBM_COPYRIGHT
				, "Enterprise PL/I for z/OS: Enterprise PL/I for z/OS Messages and Codes");
		
		createRulesFromString(s, "^IBM\\d{4}I\\s[IWESU]\\s", 3);
		createRulesFromString(s, "^IBM\\d{4}\\s", 1);
		
		//Undocumented
		writeRule("IBM1063I"
				, targetPackage
				, 'I'
				, "Code generated for DO group would be more efficient if control variable were a 4-byte integer."
				, "The control variable in the DO loop is a 1-byte integer, 2-byte integer, fixed decimal or fixed picture, and consequently, the code generated for the loop will not be optimal.");
		
		writeRule("IBM2811I"
				, targetPackage
				, 'I'
				, "Use of PICTURE as DO control variable is not recommended."
				, "If the control variable in a DO loop is a PICTURE variable, then more code will be generated for the loop than if the control variable were a FIXED BIN variable. Moreover, such loops may easily be miscoded so that they will loop infinitely.");
		
		writeRule("IBM2804I"
				, targetPackage
				, 'I'
				, "Boolean is compared with something other than '1'b or '0'b."
				, "This message will flag statements such as the following, where \"true\" is a BIT(1) STATIC INIT('1'b). It would be better if \"true\" were a named constant, i.e. if it were declared with the VALUE attribute rather than STATIC INIT. <b>if ( a < b ) = true then");
		
		writeRule("IBM2843I"
				, targetPackage
				, 'I'
				, "The defined structure struct name is alignment byte aligned, but occupies only storage size bytes of storage."
				, "Defined structures must occupy a number of bytes that is a multiple of the structure’s alignment. So, for example, if a structure contains an aligned fixed bin(31) (or other aligned fullword) field as its most stringently aligned item, then the structure must occupy a multiple of 4 bytes. The following structure does not meet this requirement: <b>define structure<b>1 point,<b>2 x fixed bin(31),<b>2 y char(1);");
	}
	private void generateAssembler() throws IOException {
		String s = stripPdf(document
				, 322
				, 48
				, IBM_COPYRIGHT
				, "High Level Assembler for z/OS & z/VM & z/VSE: Programmer's Guide"
				, "•");
		
		createRulesFromString(s, "(^ASMA\\d{3}[INWESCU]\\s)|(^ASMACMS\\d{3}E\\s)", 2);
	}
	private void generateCcpp() throws IOException {
		String s = stripPdf(document
				, 15
				, 341
				, IBM_COPYRIGHT
				, "z/OS: z/OS XL C/C++ Messages");
		
		createRulesFromString(s, "(^CCN\\d{4}\\s)|(^CDA\\d{4}\\s)", 1);
		createRulesFromString(s, "EDC\\d{4}\\s\\d{2}\\s", 4);
	}
	
	private void generateCobol() throws IOException {
		try(InputStream is = new FileInputStream(document)) {
			List<String> l = IOUtils.readLines(is, StandardCharsets.UTF_8);
			
			StringBuilder sb = new StringBuilder();
			
			for (String s0 : l) {
				if (!(s0.startsWith("1PP 5655-EC6") || s0.trim().length() == 1)) {	// Page header
					sb.append(s0.substring(1).trim());
					sb.append(' ');
				}
			}
			
			String s = sb.toString();
			
			for (String msg : getSections(s, "IGYXX\\d{4}\\-[IWESU]")) {
				String key = msg.substring(0, 9);
				char sev = msg.charAt(10);
				
				String name;
				String desc;
				
				int idx = msg.indexOf('.');
				
				if (idx > 0) {
					name = msg.substring(16, idx).trim();
					desc = msg.substring(16).trim();
				} else {
					name = msg.substring(16).trim();
					desc = name;
				}
				
				writeRule(key, targetPackage, sev, name, desc);
			}
		}
	}
	/**
	 * Converts a pdf to a string, cutting out some lines.
	 * @param doc IBM documentation
	 * @param fromPage strip all pages before
	 * @param numPages number of pages to convert
	 * @param exclude Strings to exclude from result (headers etc.)
	 * @return the converted document as string
	 * @throws IOException if the documentation cannot be read
	 */
	private String stripPdf(File doc, int fromPage, int numPages, String... exclude) throws IOException {
		PDDocument ibmMessagesAndCodes = PDDocument.load(doc);
		
		for (int i = 0; i < fromPage; ++i) {
			ibmMessagesAndCodes.removePage(0);
		}
		
		while (ibmMessagesAndCodes.removePage(numPages))
			;
		
		PDFTextStripper pdfts = new PDFTextStripper();
		
		String s = pdfts.getText(ibmMessagesAndCodes);
		
		ibmMessagesAndCodes.close();
		
		Iterator<String> iterator = s.lines().iterator();
		
		StringBuilder result = new StringBuilder();
		
		while (iterator.hasNext()) {
			String l = iterator.next();
			
			if (!containsAny(l, exclude)) {
				result.append(l);
				result.append(System.lineSeparator());
			}
		}
		
		return result.toString();
	}
	
	private void createRulesFromString(String s, String split, int goBack) throws IOException {
		Pattern p = Pattern.compile(split, Pattern.MULTILINE);
		
		for (String msg : getSections(s, split)) {
			Matcher m = p.matcher(msg);
			
			m.find();
			
			int keyEnd = m.end();
			
			char sev = msg.charAt(keyEnd - 2); // Message always ends with a blank so we must go back 2 chars
			
			if (StringUtils.containsNone(String.valueOf(sev), "INWESU")) {
				sev = 'I';
			}
			
			String name;
			String description;
			String key;
			
			int explanation = msg.indexOf("Explanation");
			
			if (explanation > -1) {
				name = msg.substring(keyEnd, explanation);
				description = msg.substring(explanation);
			} else {
				name = msg.substring(keyEnd);
				description = name;
			}
			
			key = msg.substring(0, keyEnd - goBack).trim();
			name = name.replace(System.lineSeparator(), " ").trim();
			description = description.replace(System.lineSeparator(), " ").trim();
			
			writeRule(key, targetPackage, sev, name, description);
		}
	}
	private List<String> getSections(String documentation, String msgPattern) {
		List<String> result = new LinkedList<>();
		
		Pattern p = Pattern.compile(msgPattern, Pattern.MULTILINE);
		
		Matcher m = p.matcher(documentation);
		
		m.find();
		int sta = m.start();
		
		while (m.find()) {
			int end = m.start();
			result.add(documentation.substring(sta, end));
			
			sta = end;
		}
		
		result.add(documentation.substring(sta));

		return result;
	}
	private void writeRule(String key, String target, char sev, String name, String description) throws IOException {
		if (rules.contains(key)) {
			getLog().warn("Rule " + key + " already added, skipping");

			return;
		}
		
		Sysuexit se = ibmuexit.get(key);
		
		String priority;
		
		if (se != null) {
			if (se.suppress) {
				getLog().debug("Rule " + key + " (" + name + ")" + " suppressed");
				return;
			} else {
				priority = computeSeverity(sev, se.severity);
				getLog().debug("Severity for rule " + key + " (" + name + ")" + " rewritten to " + priority);
			}
		} else {
			priority = computeSeverity(sev, -1);
		}
		
		String escapedName = StringEscapeUtils.escapeJava(name);
		String escapedDesc = StringEscapeUtils.escapeJava(description);
		
		String rule = MessageFormat.format(ruleTemplate, key, escapedName.substring(0, Math.min(escapedName.length(), 200)), escapedDesc, target, priority);
		
		Path dir = Paths.get(outputDirectory.getCanonicalPath(), targetPackage.replace('.', File.separatorChar));
		
		Files.createDirectories(dir);
		
		Path f = Paths.get(dir.toString(), key + ".java");
		
		Files.writeString(f, rule, StandardOpenOption.CREATE, StandardOpenOption.WRITE);
		
		++num;
	}
	
	private static boolean containsAny(String line, String... contain) {
		for (String p : contain) {
			if (line.contains(p)) {
				return true;
			}
		}
		
		return false;
	}
	private void initExit() {
		try (InputStream is = new FileInputStream(sysuexit)) {
			getLog().info("Applying SYSUEXIT from " + sysuexit);
			for (String s : IOUtils.readLines(is, StandardCharsets.UTF_8)) {
				if (s.substring(2, 7).equals("'IBM'")) {
					Sysuexit se = new Sysuexit();
					
					se.suppress = s.charAt(35) == '1';
					se.severity = Integer.valueOf(s.substring(23, 25).strip());
					
					ibmuexit.put("IBM" + s.substring(12, 16) + "I", se);
				}
			}
		} catch (IOException e) {
			getLog().info("SYSUXIT not found. Default severities apply");
			
			ibmuexit = new TreeMap<>();
		}
	}
	private String computeSeverity(char sev, int overrule) {
		char c;
		
		switch (overrule) {
		case 0:
			c = 'I';
			break;
		case 4:
			c = 'W';
			break;
		case 8:
			c = 'E';
			break;
		case 12:
			c = 'S';
			break;
		case 16:
			c = 'U';
			break;
		case -1:
		default:
			c = sev;
			break;
		}
		
		switch (c) {
		case 'I':
		case 'N':
			return("INFO");
		case 'W':
			return("MINOR");
		case 'E':
			return("MAJOR");
		case 'S':
			return("CRITICAL");
		case 'U':
		default:
			return("BLOCKER");
		}
		
	}
	
	public void setDocument(File document) {
		this.document = document;
	}
	public void setLang(String lang) {
		this.lang = lang;
	}

	public void setSysuexit(File sysuexit) {
		this.sysuexit = sysuexit;
	}

	public File getOutputDirectory() {
		return outputDirectory;
	}

	public String getTargetPackage() {
		return targetPackage;
	}
}
